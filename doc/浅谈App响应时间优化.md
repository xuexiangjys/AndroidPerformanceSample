# 浅谈App响应时间优化

> 响应时间，它是用来衡量系统运行效率的一个重要指标。评价一个应用的响应时间，可以从用户感知和系统性能这两个角度来考量。

响应时间的长短，可能影响用户对某个功能、某个应用、乃至某个系统的使用。毕竟如果有选择，没有哪个人会愿意去使用卡顿的应用，运行慢的手机。

作为一名开发者，虽然我们平时可能只关注于堆业务，根本就没有时间或者机会去优化我们程序的响应时间，但是这些内容对我们个人的技术成长是至关重要的。大的不说，这部分也是面试中经常考察的内容，知道了也不至于吃亏。

那么接下来我们就长话短说，赶紧来瞧瞧，到底如何来优化我们应用的响应时间。

## 核心原则

> 在算法中，我们经常会从`时间复杂度`和`空间复杂度`这两个纬度来衡量算法的优劣。

很多时候，我们无法做到`时间复杂度`和`空间复杂度`两者都最佳，只能在"时间"和"空间"中，取折中的最优解。同样的，如果我们追求最极致的"时间"最佳，就可能需要牺牲一部分的"空间"，这就是拿"空间"换"时间"的解法。

即**响应时间优化的核心**：空间 -> 时间 （用空间换时间）

那么我们应该怎么做呢？下面是我归纳总结出来的四项基本原则：

* 1.缓存优先：能读缓存读缓存。
* 2.减少新建：能复用绝不新建。
* 3.减少任务：能不做的尽量不做。
* 4.具体问题具体分析：针对具体事务本身进行分析，必须做的能提前做就提前做，不必须做的延后做。

## 优化措施

可能我上面说的这些核心和基本原则，对绝大多数人来说都非常好理解，但是知道了这些，并不代表你懂得如何进行优化。 这就好比你高中学数学，即便告诉了你一堆的公式，但真要让你来一道相关的应用题，你还真不一定能解得出来，这个时候"例题"就很关键了。

同样的，即便你知道了一些关于应用响应时间优化的核心和原则后，当你真正面临具体的优化问题时，你可能也会手足无措。

所以，接下来我就从`任务执行`、`资源加载`、`数据结构`、`线程/IO`和`页面渲染`这五个角度，来给出我的优化建议。

### 任务执行

* 1.业务/任务梳理：对业务进行拆分，对任务进行整合。
* 2.任务转换：串行 -> 并行, 同步 -> 异步。
* 3.执行顺序按优先级调整。
* 4.延迟执行、空闲执行，如:`IdleHandler`。

#### 业务/任务梳理

> 业务往往是由一个个任务流组合而成。合理的业务/任务粒度可以有效提高响应的速度。

对业务和任务的梳理，正确的方式是先进行业务的拆分，将业务拆分为一个个子任务，再根据需要对子任务进行整合。

（1）对不合理的业务流进行拆分。

* 对业务进行拆分，拆分出主要（必要）业务和次要（非必要）业务。
* 分别对主要业务和次要业务进行优先级评估，业务执行按优先级从高到底依次执行。

（2）对任务流进行整合。

* 多个相关的串行任务，可以整合为统一的业务整体。
* 多个不相关的串行任务，可以整合为一个并行的业务。

#### 任务转换

1.串行 -> 并行的适用范围： 

* 多个不相关的串行任务。
* 多个任务弱相关且耗时，但是耗时接近。例如某个页面你需要调用多个模块的接口查询数据进行展示。

2.同步 -> 异步的适用范围：

* 非必要（重要性不高）且耗时的任务。
* 耗时且关联性不大的任务。
* 耗时且存在一定相关性的任务。使用`异步线程 + 同步锁`的方式执行。

#### 任务优先级

> 类似线程中的优先级Priority，当系统资源紧张的时候，优先执行优先级高的线程。

首先我们要对应用内所有需要优化的业务以及其子任务的优先级进行定义，然后按优先级顺序进行排列和执行。

那么如何才能保证任务被按优先级进行执行呢？

1.对于线程，我们可以直接设置其Priority值。（但是一般我们不能直接使用线程，所有这个可以忽略）
2.对于线程池，我们可以从代码层将任务按优先级顺序加入到线程池中。注意，这里的线程池最好是阻塞式的，例如：使用PriorityBlockingQueue实现的优先级线程池 [PriorityThreadPoolExecutor](https://github.com/xuexiangjys/XTask/blob/master/xtask-thread/src/main/java/com/xuexiang/xtask/thread/pool/PriorityThreadPoolExecutor.java) 。
3.使用第三方的任务执行框架，这里推荐我开源的 [XTask](https://github.com/xuexiangjys/XTask) 供大家参考。

#### 延迟执行

> 延迟执行，是将一些不必要、重要性不高或者高耗时的任务暂停执行，等后面资源充足或者要使用时才执行。

常见的延迟执行有以下几种：

* 延迟某个特定的时间执行。例如：某应用启动后，每隔2分钟同步一下用户状态。
* 待某个特定的任务执行完成之后再执行。例如：导航应用定位获取成功后，再执行目的地推荐获取的任务。
* 直接不执行，等相关业务用到的时候再执行。
* 空闲执行，等待页面都完全渲染完毕之后再执行。例如：使用`IdleHandler`，具体使用如下：

```java
Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
    @Override
    public boolean queueIdle() {
        // 执行你的任务
        return false;
    }
});
```

当然，如果你想在空闲的时候执行多个任务，你也可以这样写：

```java
public class DelayTaskQueue {

  private final Queue<Runnable> mDelayTasks = new LinkedList<>();

  private final MessageQueue.IdleHandler mIdleHandler = () -> {
    if (mDelayTasks.size() > 0) {
      Runnable task = mDelayTasks.poll();
      if (task != null) {
        task.run();
      }
    }
    // mDelayTasks非空时返回ture表示下次继续执行，为空时返回false系统会移除该IdleHandler不再执行
    return !mDelayTasks.isEmpty();
  };

  public DelayTaskQueue addTask(Runnable task) {
    mDelayTasks.add(task);
    return this;
  }

  public void start() {
    Looper.myQueue().addIdleHandler(mIdleHandler);
  }
}
```

### 资源加载

* 1.懒加载
* 2.部分加载（分段加载）
* 3.预加载（数据、布局页面等）

### 数据结构

* 1.数据结构优化（空间大小、读取速度、复用性、扩展性），例如：ArrayList和LinkedList、HashMap和SparseArray。
* 2.数据缓存（内存缓存、磁盘缓存、网络缓存），分段缓存。这里可以参考glide.
* 3.锁优化（减少过度锁，避免死锁），悲观锁/乐观锁。
* 4.内存优化，避免内存抖动，频繁GC（尤其关注bitmap）

### 线程/IO

* 1.线程优化（统一、优先级调度、任务特性）
* 2.IO优化（网络IO和磁盘IO），核心是减少IO次数
    * 网络：请求合并，请求链路优化，请求体优化，系列化和反序列化优化，请求复用等。
    * 磁盘：文件随机读写、SharePreference读写等（例如对于读多写少的，可使用内存缓存）
* 3.log优化（循环中的log打印，不必要的log打印，log等级）

### 页面渲染

* 1.降低布局层级、减少嵌套、避免过度渲染（背景）(merge，ConstraintLayout)
* 2.页面复用(include)
* 3.页面懒加载
* 4.布局延迟加载(ViewStub)
* 5.inflate优化（布局预加载+异步加载，动态new控件/X2C）
* 6.动画优化（注意动画的执行耗时和内存占用）
* 7.自定义view优化（减少onDraw、onLayout、onMeasure的对象创建和执行耗时）
* 8.bitmap和canvas优化（bitmap大小、质量、压缩、复用；canvas复用，clipRect）
* 9.RecycleView优化（减少刷新次数，缓存复用）

## 推荐工具

* systrace、[Perfetto](https://ui.perfetto.dev/#!/) 、Profile
* [DoKit](https://github.com/didi/DoKit)
* [LeakCanary](https://github.com/square/leakcanary)
* [performance](https://github.com/xanderwang/performance)

> 我是xuexiangjys，一枚热爱学习，爱好编程，勤于思考，致力于Android架构研究以及开源项目经验分享的技术up主。获取更多资讯，欢迎微信搜索公众号：**【我的Android开源之旅】**

